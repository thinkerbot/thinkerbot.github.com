<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Configurable::ClassMethods</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Configurable::ClassMethods</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../files/lib/configurable/class_methods_rb.html">
                lib/configurable/class_methods.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="ClassMethods.html">ClassMethods</a> extends classes that include
<a href="../Configurable.html">Configurable</a> and provides methods for
declaring configurations.
</p>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000043">c</a>&nbsp;&nbsp;
      <a href="#M000040">config</a>&nbsp;&nbsp;
      <a href="#M000041">config_attr</a>&nbsp;&nbsp;
      <a href="#M000042">nest</a>&nbsp;&nbsp;
      <a href="#M000037">parse</a>&nbsp;&nbsp;
      <a href="#M000038">parse!</a>&nbsp;&nbsp;
      <a href="#M000039">use_indifferent_access</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->
    <div id="includes">
      <h3 class="section-bar">Included Modules</h3>

      <div id="includes-list">
        <span class="include-name">Lazydoc::Attributes</span>
        <span class="include-name"><a href="../Configurable.html">Configurable</a></span>
      </div>
    </div>

    <div id="section">





    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">configurations</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc">
A hash of (key, <a href="Delegate.html">Delegate</a>) pairs defining the
class configurations.

</td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000037" class="method-detail">
        <a name="M000037"></a>

        <div class="method-heading">
          <a href="#M000037" class="method-signature">
          <span class="method-name">parse</span><span class="method-args">(argv=ARGV, options={}) {|parser| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Parses configurations from argv in a non-destructive manner by generating a
<a href="../ConfigParser.html">ConfigParser</a> using the configurations
for self. Returns an array like
</p>
<dl>
<dt>args, <a href="ClassMethods.html#M000040">config</a></dt><dd>where the args are the arguments that remain after parsing,

</dd>
</dl>
<p>
and <a href="ClassMethods.html#M000040">config</a> is a hash of the parsed
configs. The parser will is yielded to the block, if given, to register
additonal options.
</p>
<p>
See <a href="../ConfigParser.html#M000012">ConfigParser#parse</a> for more
information.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000037-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000037-source">
<pre>
    <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 40</span>
40:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">parse</span>(<span class="ruby-identifier">argv</span>=<span class="ruby-constant">ARGV</span>, <span class="ruby-identifier">options</span>={}) <span class="ruby-comment cmt"># :yields: parser</span>
41:       <span class="ruby-identifier">parse!</span>(<span class="ruby-identifier">argv</span>.<span class="ruby-identifier">dup</span>, <span class="ruby-identifier">options</span>)
42:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000038" class="method-detail">
        <a name="M000038"></a>

        <div class="method-heading">
          <a href="#M000038" class="method-signature">
          <span class="method-name">parse!</span><span class="method-args">(argv=ARGV, options={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Same as <a href="ClassMethods.html#M000037">parse</a>, but removes parsed
args from argv.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000038-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000038-source">
<pre>
    <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 45</span>
45:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">parse!</span>(<span class="ruby-identifier">argv</span>=<span class="ruby-constant">ARGV</span>, <span class="ruby-identifier">options</span>={})
46:       <span class="ruby-identifier">parser</span> = <span class="ruby-constant">ConfigParser</span>.<span class="ruby-identifier">new</span>
47:       <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">configurations</span>)
48:       
49:       <span class="ruby-identifier">args</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">parse!</span>(<span class="ruby-identifier">argv</span>, <span class="ruby-identifier">options</span>)
50:       [<span class="ruby-identifier">args</span>, <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">config</span>]
51:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Protected Instance methods</h3>

      <div id="method-M000043" class="method-detail">
        <a name="M000043"></a>

        <div class="method-heading">
          <a href="#M000043" class="method-signature">
          <span class="method-name">c</span><span class="method-args">()</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Alias for <a href="Validation.html">Validation</a>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000043-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000043-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 355</span>
355:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">c</span>
356:       <span class="ruby-constant">Validation</span>
357:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000040" class="method-detail">
        <a name="M000040"></a>

        <div class="method-heading">
          <a href="#M000040" class="method-signature">
          <span class="method-name">config</span><span class="method-args">(key, value=nil, attributes={}) {|input| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Declares a class configuration and generates the associated accessors. If a
block is given, the <tt>key=</tt> method will set <tt>@key</tt> to the
return of the block, which executes in class-context.
</p>
<pre>
  class SampleClass
    include Configurable

    config :str, 'value'
    config(:upcase, 'value') {|input| input.upcase }
  end

  # An equivalent class to illustrate class-context
  class EquivalentClass
    attr_accessor :str
    attr_reader :upcase

    UPCASE_BLOCK = lambda {|input| input.upcase }

    def upcase=(input)
      @upcase = UPCASE_BLOCK.call(input)
    end
  end
</pre>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000040-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000040-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 89</span>
 89:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">config</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">attributes</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
 90:       <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">merge_attributes</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">attributes</span>)
 91:       
 92:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
 93:         <span class="ruby-identifier">instance_variable</span> = <span class="ruby-node">&quot;@#{key}&quot;</span>.<span class="ruby-identifier">to_sym</span>
 94:         <span class="ruby-identifier">config_attr</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">attributes</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">input</span><span class="ruby-operator">|</span>
 95:           <span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-identifier">instance_variable</span>, <span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">input</span>))
 96:         <span class="ruby-keyword kw">end</span>
 97:       <span class="ruby-keyword kw">else</span>
 98:         <span class="ruby-identifier">config_attr</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">attributes</span>)
 99:       <span class="ruby-keyword kw">end</span>
100:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000041" class="method-detail">
        <a name="M000041"></a>

        <div class="method-heading">
          <a href="#M000041" class="method-signature">
          <span class="method-name">config_attr</span><span class="method-args">(key, value=nil, attributes={}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Declares a class configuration and generates the associated accessors. If a
block is given, the <tt>key=</tt> method will perform the block with
instance-context.
</p>
<pre>
  class SampleClass
    include Configurable

    def initialize
      initialize_config
    end

    config_attr :str, 'value'
    config_attr(:upcase, 'value') {|input| @upcase = input.upcase }
  end

  # An equivalent class to illustrate instance-context
  class EquivalentClass
    attr_accessor :str
    attr_reader :upcase

    def upcase=(input)
      @upcase = input.upcase
    end
  end
</pre>
<h3>Attributes</h3>
<p>
Several attributes may be specified to modify how a <a
href="ClassMethods.html#M000040">config</a> is constructed. Attribute keys
should be specified as symbols.
</p>
<table>
<tr><td valign="top">Attribute:</td><td>Description

</td></tr>
<tr><td valign="top">reader:</td><td>The method used to read the configuration. (default: key)

</td></tr>
<tr><td valign="top">writer:</td><td>The method used to write the configuration (default: &quot;#{key}=&quot;)

</td></tr>
</table>
<p>
Neither attribute may be set to nil, but they may be set to non-default
values. In that case, <a href="ClassMethods.html#M000041">config_attr</a>
will register the method names as provided, but it will not define the
methods themselves. Specifying true uses and defines the default methods.
Specifying false uses the default method name, but does not define the
method itself.
</p>
<p>
Any additional attributes are registered with the configuration.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000041-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000041-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 145</span>
145:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">config_attr</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">attributes</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
146:       <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">merge_attributes</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">attributes</span>)
147:       
148:       <span class="ruby-comment cmt"># define the reader</span>
149:       <span class="ruby-identifier">reader</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">key</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
150:         <span class="ruby-identifier">attr_reader</span>(<span class="ruby-identifier">attribute</span>) 
151:         <span class="ruby-identifier">public</span>(<span class="ruby-identifier">attribute</span>)
152:       <span class="ruby-keyword kw">end</span>
153:       
154:       <span class="ruby-comment cmt"># define the writer</span>
155:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">attributes</span>[<span class="ruby-identifier">:writer</span>] <span class="ruby-operator">!=</span> <span class="ruby-keyword kw">true</span>
156:         <span class="ruby-identifier">raise</span> <span class="ruby-constant">ArgumentError</span>, <span class="ruby-value str">&quot;a block may not be specified without writer == true&quot;</span>
157:       <span class="ruby-keyword kw">end</span>
158:       
159:       <span class="ruby-identifier">writer</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:writer</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-node">&quot;#{key}=&quot;</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
160:         <span class="ruby-identifier">block_given?</span> <span class="ruby-value">? </span><span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">attribute</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">attr_writer</span>(<span class="ruby-identifier">key</span>)
161:         <span class="ruby-identifier">public</span>(<span class="ruby-identifier">attribute</span>)
162:       <span class="ruby-keyword kw">end</span>
163:       
164:       <span class="ruby-identifier">configurations</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-constant">Delegate</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">writer</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">attributes</span>)
165:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000042" class="method-detail">
        <a name="M000042"></a>

        <div class="method-heading">
          <a href="#M000042" class="method-signature">
          <span class="method-name">nest</span><span class="method-args">(key, configurable_class=nil, attributes={}, &amp;block)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Adds nested configurations to self. Nest creates a new configurable class
using the block, and provides accessors to an instance of the new class.
Everything is set up so you can access configs through the instance or
through <a href="ClassMethods.html#M000040">config</a>.
</p>
<pre>
  class A
    include Configurable

    config :key, 'one'
    nest :nest do
      config :key, 'two'
    end
  end

  a = A.new
  a.key                     # =&gt; 'one'
  a.config[:key]            # =&gt; 'one'

  a.nest.key                # =&gt; 'two'
  a.config[:nest][:key]     # =&gt; 'two'

  a.nest.key = 'TWO'
  a.config[:nest][:key]     # =&gt; 'TWO'

  a.config[:nest][:key] = 2
  a.nest.key                # =&gt; 2

  a.config.to_hash          # =&gt; {:key =&gt; 'one', :nest =&gt; {:key =&gt; 2}}
  a.nest.config.to_hash     # =&gt; {:key =&gt; 2}
  a.nest.class              # =&gt; A::Nest
</pre>
<p>
An existing configurable class may be provided instead of using the block
to define a new configurable class. Recursive nesting is supported.
</p>
<pre>
  class B
    include Configurable

    config :key, 1, &amp;c.integer
    nest :nest do
      config :key, 2, &amp;c.integer
      nest :nest do
        config :key, 3, &amp;c.integer
      end
    end
  end

  class C
    include Configurable
    nest :a, A
    nest :b, B
  end

  c = C.new
  c.b.key = 7
  c.b.nest.key = &quot;8&quot;
  c.config[:b][:nest][:nest][:key] = &quot;9&quot;

  c.config.to_hash
  # =&gt; {
  # :a =&gt; {
  #   :key =&gt; 'one',
  #   :nest =&gt; {:key =&gt; 'two'}
  # },
  # :b =&gt; {
  #   :key =&gt; 7,
  #   :nest =&gt; {
  #     :key =&gt; 8,
  #     :nest =&gt; {:key =&gt; 9}
  #   }
  # }}
</pre>
<h3>Attributes</h3>
<p>
Nest provides a number of attributes that can modify how a <a
href="ClassMethods.html#M000042">nest</a> is constructed. Attribute keys
should be specified as symbols.
</p>
<table>
<tr><td valign="top">Attribute:</td><td>Description

</td></tr>
<tr><td valign="top">const_name:</td><td>Determines the constant name of the configurable class within the nesting
class. May be nil. (default: key.to_s.capitalize)

</td></tr>
<tr><td valign="top">instance_reader:</td><td>The method accessing the nested instance. (default: key)

</td></tr>
<tr><td valign="top">instance_writer:</td><td>The method to set the nested instance. (default: &quot;#{key}=&quot;)

</td></tr>
<tr><td valign="top">reader:</td><td>The method used to read the instance <a
href="ClassMethods.html#M000040">config</a>. (default:
&quot;#{key}_config_reader&quot;)

</td></tr>
<tr><td valign="top">writer:</td><td>The method used to reconfigure the instance. (default:
&quot;#{key}_config_writer&quot;)

</td></tr>
</table>
<p>
Except for const_name, these attributes are used to define methods required
for nesting to work properly. None of the method attributes may be set to
nil, but they may be set to non-default values. In that case, <a
href="ClassMethods.html#M000042">nest</a> will register the method names as
provided, but it will not define the methods themselves. The user must
define methods with the following functionality:
</p>
<table>
<tr><td valign="top">Attribute:</td><td>Function

</td></tr>
<tr><td valign="top">instance_reader:</td><td>Returns the instance of the configurable class (initializing if necessary,
by default <a href="ClassMethods.html#M000042">nest</a> initializes using
configurable_class.new)

</td></tr>
<tr><td valign="top">instance_writer:</td><td>Inputs and sets the instance of the configurable class

</td></tr>
<tr><td valign="top">reader:</td><td>Returns instance.config

</td></tr>
<tr><td valign="top">writer:</td><td>Reconfigures instance using the input overrides, or sets instance if
provided.

</td></tr>
</table>
<p>
Methods can be public or otherwise. Specifying true uses and defines the
default methods. Specifying false uses the default method name, but does
not define the method itself.
</p>
<p>
Any additional attributes are registered with the configuration.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000042-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000042-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 275</span>
275:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">nest</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">configurable_class</span>=<span class="ruby-keyword kw">nil</span>, <span class="ruby-identifier">attributes</span>={}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
276:       <span class="ruby-identifier">attributes</span> = <span class="ruby-identifier">merge_attributes</span>(<span class="ruby-identifier">block</span>, <span class="ruby-identifier">attributes</span>)
277:       <span class="ruby-identifier">attributes</span> = {
278:         <span class="ruby-identifier">:instance_reader</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>,
279:         <span class="ruby-identifier">:instance_writer</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">true</span>,
280:       }.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">attributes</span>)
281:       
282:       <span class="ruby-comment cmt"># define the nested configurable</span>
283:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">configurable_class</span>
284:         <span class="ruby-identifier">raise</span> <span class="ruby-value str">&quot;a block is not allowed when a configurable class is specified&quot;</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
285:       <span class="ruby-keyword kw">else</span>
286:         <span class="ruby-identifier">configurable_class</span> = <span class="ruby-constant">Class</span>.<span class="ruby-identifier">new</span> { <span class="ruby-identifier">include</span> <span class="ruby-constant">Configurable</span> }
287:         <span class="ruby-identifier">configurable_class</span>.<span class="ruby-identifier">class_eval</span>(<span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>) <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">block_given?</span>
288:       <span class="ruby-keyword kw">end</span>
289:       
290:       <span class="ruby-comment cmt"># set the new constant</span>
291:       <span class="ruby-identifier">const_name</span> = <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">:const_name</span>) 
292:         <span class="ruby-identifier">attributes</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">:const_name</span>) 
293:       <span class="ruby-keyword kw">else</span>
294:         <span class="ruby-identifier">key</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">capitalize</span>
295:       <span class="ruby-keyword kw">end</span>
296:       
297:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">const_name</span>
298:         <span class="ruby-comment cmt"># this prevents a warning in cases where the nesting</span>
299:         <span class="ruby-comment cmt"># class defines the configurable_class</span>
300:         <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">const_defined?</span>(<span class="ruby-identifier">const_name</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">const_get</span>(<span class="ruby-identifier">const_name</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">configurable_class</span>
301:           <span class="ruby-identifier">const_set</span>(<span class="ruby-identifier">const_name</span>, <span class="ruby-identifier">configurable_class</span>)
302:         <span class="ruby-keyword kw">end</span>
303:       <span class="ruby-keyword kw">end</span>
304:       
305:       <span class="ruby-comment cmt"># define instance reader</span>
306:       <span class="ruby-identifier">instance_reader</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:instance_reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-identifier">key</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
307:         <span class="ruby-identifier">instance_variable</span> = <span class="ruby-node">&quot;@#{key}&quot;</span>.<span class="ruby-identifier">to_sym</span>
308:         
309:         <span class="ruby-comment cmt"># gets or initializes the instance</span>
310:         <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">attribute</span>) <span class="ruby-keyword kw">do</span>
311:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-identifier">instance_variable</span>)
312:             <span class="ruby-identifier">instance_variable_get</span>(<span class="ruby-identifier">instance_variable</span>)
313:           <span class="ruby-keyword kw">else</span>
314:             <span class="ruby-identifier">instance_variable_set</span>(<span class="ruby-identifier">instance_variable</span>, <span class="ruby-identifier">configurable_class</span>.<span class="ruby-identifier">new</span>)
315:           <span class="ruby-keyword kw">end</span>
316:         <span class="ruby-keyword kw">end</span>
317:         
318:         <span class="ruby-identifier">public</span>(<span class="ruby-identifier">key</span>)
319:       <span class="ruby-keyword kw">end</span>
320:       
321:       <span class="ruby-comment cmt"># define instance writer</span>
322:       <span class="ruby-identifier">instance_writer</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:instance_writer</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-node">&quot;#{key}=&quot;</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
323:         <span class="ruby-identifier">attr_writer</span>(<span class="ruby-identifier">key</span>)
324:         <span class="ruby-identifier">public</span>(<span class="ruby-identifier">attribute</span>)
325:       <span class="ruby-keyword kw">end</span>
326:       
327:       <span class="ruby-comment cmt"># define the reader</span>
328:       <span class="ruby-identifier">reader</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:reader</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-node">&quot;#{key}_config_reader&quot;</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
329:         <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">attribute</span>) <span class="ruby-keyword kw">do</span>
330:           <span class="ruby-identifier">send</span>(<span class="ruby-identifier">instance_reader</span>).<span class="ruby-identifier">config</span>
331:         <span class="ruby-keyword kw">end</span>
332:         <span class="ruby-identifier">private</span>(<span class="ruby-identifier">attribute</span>)
333:       <span class="ruby-keyword kw">end</span>
334:       
335:       <span class="ruby-comment cmt"># define the writer</span>
336:       <span class="ruby-identifier">writer</span> = <span class="ruby-identifier">define_attribute_method</span>(<span class="ruby-identifier">:writer</span>, <span class="ruby-identifier">attributes</span>, <span class="ruby-node">&quot;#{key}_config_writer&quot;</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">attribute</span><span class="ruby-operator">|</span>
337:         <span class="ruby-identifier">define_method</span>(<span class="ruby-identifier">attribute</span>) <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
338:           <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">value</span>.<span class="ruby-identifier">kind_of?</span>(<span class="ruby-identifier">configurable_class</span>)
339:             <span class="ruby-identifier">send</span>(<span class="ruby-identifier">instance_writer</span>, <span class="ruby-identifier">value</span>)
340:           <span class="ruby-keyword kw">else</span>
341:             <span class="ruby-identifier">send</span>(<span class="ruby-identifier">instance_reader</span>).<span class="ruby-identifier">reconfigure</span>(<span class="ruby-identifier">value</span>)
342:           <span class="ruby-keyword kw">end</span>
343:         <span class="ruby-keyword kw">end</span>
344:         <span class="ruby-identifier">private</span>(<span class="ruby-identifier">attribute</span>)
345:       <span class="ruby-keyword kw">end</span>
346:       
347:       <span class="ruby-comment cmt"># define the configuration</span>
348:       <span class="ruby-identifier">nested_config</span> = <span class="ruby-constant">DelegateHash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">configurable_class</span>.<span class="ruby-identifier">configurations</span>)
349:       <span class="ruby-identifier">configurations</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-constant">Delegate</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">reader</span>, <span class="ruby-identifier">writer</span>, <span class="ruby-identifier">nested_config</span>, <span class="ruby-identifier">attributes</span>)
350:       
351:       <span class="ruby-identifier">check_infinite_nest</span>(<span class="ruby-identifier">configurable_class</span>.<span class="ruby-identifier">configurations</span>)
352:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000039" class="method-detail">
        <a name="M000039"></a>

        <div class="method-heading">
          <a href="#M000039" class="method-signature">
          <span class="method-name">use_indifferent_access</span><span class="method-args">(input=true)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Sets configurations to symbolize keys for AGET ([]) and ASET([]=)
operations, or not. By default, configurations will use indifferent access.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000039-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000039-source">
<pre>
    <span class="ruby-comment cmt"># File lib/configurable/class_methods.rb, line 58</span>
58:     <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">use_indifferent_access</span>(<span class="ruby-identifier">input</span>=<span class="ruby-keyword kw">true</span>)
59:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">input</span>
60:         <span class="ruby-ivar">@configurations</span>.<span class="ruby-identifier">extend</span>(<span class="ruby-constant">IndifferentAccess</span>)
61:       <span class="ruby-keyword kw">else</span>
62:         <span class="ruby-ivar">@configurations</span> = <span class="ruby-identifier">configurations</span>.<span class="ruby-identifier">dup</span>
63:       <span class="ruby-keyword kw">end</span>
64:     <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>