<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: Config Syntax.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>Config Syntax.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>Help/Config Syntax.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 24 13:54:20 -0600 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Config Syntax</h1>
<p>
Declare configurations by key, and provide a default value. Declaring a
config generates accessors with the same name and sets up access through
config.
</p>
<pre>
  class ConfigClass
    include Configurable
    config :str, 'one'
  end

  c = ConfigClass.new
  c.str                      # =&gt; 'one'
  c.str = 'two'
  c.config[:str]             # =&gt; 'two'
  c.config[:str] = 'three'
  c.str                      # =&gt; 'three'
  c.config.to_hash           # =&gt; {:str =&gt; 'three'}
</pre>
<h2>Initialization</h2>
<p>
Call initialize_config during initialization to setup config with
non-default values.
</p>
<pre>
  class InitClass
    include Configurable
    config :str, 'one'

    def initialize(configs={})
      initialize_config(configs)
    end
  end

  c = InitClass.new(:str =&gt; 'two')
  c.str                      # =&gt; 'two'
</pre>
<h2>Key/Name</h2>
<p>
Configs have both a key and a name. The key may be any object and provides
access to a configuration in config. The name must be a string and an
ordinary word. Name used gets used wherever a word-based-identifier is
needed, for instance when creating accessors.
</p>
<p>
By default name is key.to_s. When key converts into an illegal name, or
when you want a different name, specify it manually.
</p>
<pre>
  class KeyNameClass
    include Configurable
    config :key, 'val', :name =&gt; 'name'
  end

  c = KeyNameClass.new
  c.name                     # =&gt; 'val'
  c.config[:key]             # =&gt; 'val'
</pre>
<h2>Reader/Writer</h2>
<p>
Specify a reader and/or writer to map configs to alternative accessors.
When you specify a reader or writer you must define the corresponding
method yourself, even if you specify default accessors (ie
&#8216;name&#8217; and &#8216;name=&#8217;). The reader takes no arguments
and the writer takes the input value.
</p>
<pre>
  class ReaderWriterClass
    include Configurable
    config :str, 'one', :reader =&gt; :get, :writer =&gt; :set

    def get
      @ivar
    end

    def set(value)
      @ivar = value
    end
  end

  c = ReaderWriterClass.new
  c.get                      # =&gt; 'one'
  c.set 'two'
  c.config[:str]             # =&gt; 'two'
  c.config[:str] = 'three'
  c.get                      # =&gt; 'three'
  c.config.to_hash           # =&gt; {:str =&gt; 'three'}
</pre>
<p>
Note that <a href="../../classes/Configurable.html">Configurable</a>
doesn&#8216;t care how the data is stored on an instance.
</p>
<h2>Import/Export</h2>
<p>
Configs may be imported/exported between the active objects used by an
instance and the static data used by textual interfaces like config files,
the command-line, and web forms.
</p>
<p>
After import, configs are composed of key-value pairs of arbitrary class
(ex a symbol key and a string value). After export, configs are composed of
name-input pairs which must be directly serializable as JSON (ex a string
name and a string input).
</p>
<p>
Import/export can occur at the class level:
</p>
<pre>
  configs = KeyNameClass.configs
  defaults = configs.to_default
  defaults                   # =&gt; {:key =&gt; 'val'}

  static_data = configs.export(defaults)
  static_data                # =&gt; {'name' =&gt; 'val'}

  active_hash = configs.import({'name' =&gt; 'VAL'})
  active_hash                # =&gt; {:key =&gt; 'VAL'}
</pre>
<p>
Or the instance level:
</p>
<pre>
  c = KeyNameClass.new
  c.config.to_hash           # =&gt; {:key =&gt; 'val'}
  c.config.export            # =&gt; {'name' =&gt; 'val'}

  c.config.import({'name' =&gt; 'VAL'})
  c.config.to_hash           # =&gt; {:key =&gt; 'VAL'}
</pre>
<p>
<a href="../../classes/Configurable.html">Configurable</a> supports
import/export of basic types (boolean, integer, float, string, array, and
hash). See later documentation to set up custom config types.
</p>
<h2>Lists</h2>
<p>
When an array of values is given as the default value, config will
construct a list-style configuration. The syntax and usage is no different
than any other config, except that type information is expected to be
preserved across all members of the array (ie an array-of-strings,
array-of-integers, etc).
</p>
<pre>
  class ListClass
    include Configurable
    config :integers, [1, 2, 3]
  end

  c = ListClass.new
  c.integers                 # =&gt; [1, 2, 3]
  c.config.import('integers' =&gt; ['7', '8'])
  c.config[:integers]        # =&gt; [7, 8]
</pre>
<h2>Nesting</h2>
<p>
<a href="../../classes/Configurable.html">Configurable</a> classes may be
nested to represent a hash within a hash. To construct a nested class,
provide a hash default of key-value pairs, a block defining the nested
class, or an instance of the nested class.
</p>
<pre>
  class Parent
    include Configurable

    config :a, {:key =&gt; 'hash'}

    config :b do
      config :key, 'block'
    end

    class Child
      include Configurable
      config :key, 'instance'
    end
    config :c, Child.new
  end

  c = Parent.new
  c.config.to_hash
  # =&gt; {
  #  :a =&gt; {:key =&gt; 'hash'},
  #  :b =&gt; {:key =&gt; 'block'},
  #  :c =&gt; {:key =&gt; 'instance'}
  # }
</pre>
<p>
Nest configs are structured to provide clean access to the nested
configurable through the accessors and config:
</p>
<pre>
  c.a.key                    # =&gt; 'hash'
  c.config[:a][:key]         # =&gt; 'hash'
  c.config[:a][:key] = 'HASH'
  c.a.key                    # =&gt; 'HASH'
  c.a.config.to_hash         # =&gt; {:key =&gt; 'HASH'}
</pre>
<p>
Instances of the nested class can be directly assigned, or they can be
initialized via config. Nested classes generated by the config method are
assigned to a constant based on the config name.
</p>
<pre>
  c.a = Parent::A.new
  c.config[:a]               # =&gt; {:key =&gt; 'hash'}
  c.config[:a] = {:key =&gt; 'HASH'}
  c.a.config.to_hash         # =&gt; {:key =&gt; 'HASH'}
</pre>
<p>
Import/export of nested classes occurs seamlessly:
</p>
<pre>
  c.config.import('b' =&gt; {'key' =&gt; 'BLOCK'})
  c.config.export
  # =&gt; {
  #  'a' =&gt; {'key' =&gt; 'HASH'},
  #  'b' =&gt; {'key' =&gt; 'BLOCK'},
  #  'c' =&gt; {'key' =&gt; 'instance'}
  # }
</pre>
<h2>Inheritance</h2>
<p>
Configurations can be inherited, overridden, declared in modules, and
generally treated like methods.
</p>
<pre>
  class A
    include Configurable
    config :a, 'one'
  end

  module B
    include Configurable
    config :b, 'two'
  end

  class C &lt; A
    include B
    config :c, 'three'
  end

  c = C.new
  c.a                   # =&gt; 'one'
  c.b                   # =&gt; 'two'
  c.c                   # =&gt; 'three'
  c.config.to_hash      # =&gt; {:a =&gt; 'one', :b =&gt; 'two', :c =&gt; 'three'}

  class D &lt; C
    config :a, 'ONE'
    undef_config :c
  end

  d = D.new
  d.respond_to?(:c)     # =&gt; false
  d.config.to_hash      # =&gt; {:a =&gt; 'ONE', :b =&gt; 'two'}
</pre>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>