<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: Config Types.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>Config Types.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>Help/Config Types.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 24 13:54:20 -0600 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h2>Config Types</h2>
<p>
Configs have two conceptual parts; a config class that determines how to
map config values between various contexts, and a config type that
determines how to cast config values. <a
href="../../classes/Configurable.html">Configurable</a> provides support
for basic types (ex booleans, numbers, strings) and a syntax to declare
custom types.
</p>
<p>
Custom types are declared using the config_type method. The config method
then matches the default against all available config types to guess the
type for the new configuration.
</p>
<pre>
  require 'time'

  now = Time.now
  class TimeExample
    include Configurable

    config_type :time, Time do |input|
      Time.parse(input)
    end.uncast do |value|
      time.strftime('%Y-%m-%d %H:%M:%S')
    end

    config :obj, now
  end

  c = TimeExample.new
  c.obj                             # =&gt; now

  c.config.import('obj' =&gt; 'Sun Dec 05 16:52:19 -0700 2010')
  c.obj.strftime('%Y-%m-%d')        # =&gt; '2010-12-05'

  c.config.export
  # =&gt; {'obj' =&gt; '2010-12-05 16:52:19'}
</pre>
<p>
Config types define how to cast/uncast values during import/export. The
type is free to determine how to do so, so long as the uncast value can be
cleanly serialized as JSON. This is also possible:
</p>
<pre>
  class RangeExample
    include Configurable

    config_type(:range, Range) do |input|
      Range.new(
        input['begin'],
        input['end'],
        input['exclusive']
      )
    end.uncast do |value|
      {
        'begin'     =&gt; value.begin,
        'end'       =&gt; value.end,
        'exclusive' =&gt; value.exclude_end?
      }
    end

    config :obj, 1..10
  end

  c = RangeExample.new
  c.obj                             # =&gt; 1..10

  c.config.import('obj' =&gt; {'begin' =&gt; 2, 'end' =&gt; 20, 'exclusive' =&gt; false})
  c.obj                             # =&gt; 2..20

  c.obj = 3...30
  c.config.export
  # =&gt; {'obj' =&gt; {'begin' =&gt; 3, 'end' =&gt; 30, 'exclusive' =&gt; true}}
</pre>
<p>
The config_type method defines a type class, which is set to a constant
according to the type name.
</p>
<pre>
  config = RangeExample.configs[:obj]
  config.type.class                 # =&gt; RangeExample::RangeType
</pre>
<h2>Matching/Inheritance</h2>
<p>
Upon declaration the config type for a config is guessed by matching the
default against all available types. Matching walks up the inheritance
hierarchy to find a match if necessary, and stops when a match is found. An
error is raised if more than one type matches for a given ancestor; in that
case the type must be specified manually.
</p>
<pre>
  class A
    include Configurable
    config_type :datetime, Date, Time, DateTime
    config :a, Time.now     # matches :datetime type
  end

  class B &lt; A
    config_type :time, Time

    config :b, Time.now     # matches :time type
    config :c, Date.today   # skips :time, walks up to match :datetime
  end

  class C &lt; B
    config_type :date1, Date
    config_type :date2, Date

    config :d, Date.today, :type =&gt; :date1  # manually specify which to match;
    config :e, Date.today, :type =&gt; :date2  # ambiguous type will raise error
  end

  configs = C.configs
  configs[:a].type.class          # =&gt; A::DatetimeType
  configs[:b].type.class          # =&gt; B::TimeType
  configs[:c].type.class          # =&gt; A::DatetimeType
  configs[:d].type.class          # =&gt; C::Date1Type
  configs[:e].type.class          # =&gt; C::Date2Type
</pre>
<p>
For nest configs defined from a block or hash, config types are guessed in
the context of the parent (although config_types defined in a nested child
do not bleed back up).
</p>
<pre>
  class Parent
    include Configurable
    config_type :datetime, Time, Date

    config :a, {:b =&gt; Time.now}
    config :c do
      config_type :time, Time

      config :d, Time.now
      config :e, Date.today
    end
    config :f, Date.today
  end

  configs = Parent.configs
  configs[:a].type.class          # =&gt; Configurable::ConfigTypes::NestType
  configs[:c].type.class          # =&gt; Configurable::ConfigTypes::NestType
  configs[:f].type.class          # =&gt; Parent::DatetimeType

  a_configs = configs[:a].type.configurable.class.configs
  a_configs[:b].type.class        # =&gt; Parent::DatetimeType

  c_configs = configs[:c].type.configurable.class.configs
  c_configs[:d].type.class        # =&gt; Parent::C::TimeType
  c_configs[:e].type.class        # =&gt; Parent::DatetimeType
</pre>
<p>
Aside from direct inheritance, config_types may be overridden, declared in
modules, and handled as if they were methods.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>