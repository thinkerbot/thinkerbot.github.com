<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Configurable</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Configurable</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../files/lib/configurable_rb.html">
                lib/configurable.rb
                </a>
        <br />
                <a href="../files/lib/configurable/class_methods_rb.html">
                lib/configurable/class_methods.rb
                </a>
        <br />
                <a href="../files/lib/configurable/config_rb.html">
                lib/configurable/config.rb
                </a>
        <br />
                <a href="../files/lib/configurable/config_hash_rb.html">
                lib/configurable/config_hash.rb
                </a>
        <br />
                <a href="../files/lib/configurable/indifferent_access_rb.html">
                lib/configurable/indifferent_access.rb
                </a>
        <br />
                <a href="../files/lib/configurable/module_methods_rb.html">
                lib/configurable/module_methods.rb
                </a>
        <br />
                <a href="../files/lib/configurable/nest_config_rb.html">
                lib/configurable/nest_config.rb
                </a>
        <br />
                <a href="../files/lib/configurable/ordered_hash_patch_rb.html">
                lib/configurable/ordered_hash_patch.rb
                </a>
        <br />
                <a href="../files/lib/configurable/utils_rb.html">
                lib/configurable/utils.rb
                </a>
        <br />
                <a href="../files/lib/configurable/validation_rb.html">
                lib/configurable/validation.rb
                </a>
        <br />
                <a href="../files/lib/configurable/version_rb.html">
                lib/configurable/version.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
<a href="Configurable.html">Configurable</a> enables the specification of
configurations within a class definition.
</p>
<pre>
  class ConfigClass
    include Configurable
    config :one, 'one'
    config :two, 'two'
    config :three, 'three'
  end

  c = ConfigClass.new
  c.config.class            # =&gt; Configurable::ConfigHash
  c.config                  # =&gt; {:one =&gt; 'one', :two =&gt; 'two', :three =&gt; 'three'}
</pre>
<p>
Instances have a <tt>config</tt> object that acts like a forwarding hash;
configuration keys delegate to accessors while undeclared key-value pairs
are stored internally:
</p>
<pre>
  c.config[:one] = 'ONE'
  c.one                     # =&gt; 'ONE'

  c.one = 1
  c.config                  # =&gt; {:one =&gt; 1, :two =&gt; 'two', :three =&gt; 'three'}

  c.config[:undeclared] = 'value'
  c.config.store            # =&gt; {:undeclared =&gt; 'value'}
</pre>
<p>
The writer for a configuration can be defined by providing a block to
config. The <a href="Configurable/Validation.html">Validation</a> module
provides a number of common validation/transform blocks accessible through
the class method &#8216;c&#8217;:
</p>
<pre>
  class ValidationClass
    include Configurable
    config(:one, 'one') {|v| v.upcase }
    config :two, 2, &amp;c.integer
  end

  c = ValidationClass.new
  c.config                  # =&gt; {:one =&gt; 'ONE', :two =&gt; 2}

  c.one = 'aNothER'
  c.one                     # =&gt; 'ANOTHER'

  c.two = -2
  c.two                     # =&gt; -2
  c.two = &quot;3&quot;
  c.two                     # =&gt; 3
  c.two = nil               # !&gt; ValidationError
  c.two = 'str'             # !&gt; ValidationError
</pre>
<p>
Note that config blocks are defined in class-context and will have access
to variables outside the block (as you would expect). For instance, these
are analagous declarations:
</p>
<pre>
  class ExampleClass
    config :key, 'value' do |input|
      input.upcase
    end
  end

  class AnalagousClass
    block = lambda {|input| input.upcase}

    define_method(:key=) do |input|
      @key = block.call(input)
    end
  end
</pre>
<p>
To have the block literally define the writer, use the config_attr method.
Blocks provided to config_attr will have instance context and must set the
instance variable themselves.
</p>
<pre>
  class LiteralClass
    config_attr :key, 'value' do |input|
      @key = input.upcase
    end
  end
</pre>
<p>
Configurations are inherited and may be overridden in subclasses. They may
also be included from a module:
</p>
<pre>
  module A
    include Configurable
    config :a, 'a'
    config :b, 'b'
  end

  class B
    include A
  end

  class C &lt; B
    config :b, 'B'
    config :c, 'C'
  end

  B.new.config.to_hash      # =&gt; {:a =&gt; 'a', :b =&gt; 'b'}
  C.new.config.to_hash      # =&gt; {:a =&gt; 'a', :b =&gt; 'B', :c =&gt; 'C'}
</pre>
<p>
Lastly, configurable classes may be nested through the nest method. Nesting
creates a configurable class with the configs defined in the nest block;
nested configs may be accessed by chaining method calls, or through nested
calls to config.
</p>
<pre>
  class NestingClass
    include Configurable
    config :one, 'one'
    nest :two do
      config :three, 'three'
    end
  end

  c = NestingClass.new
  c.config.to_hash          # =&gt; {:one =&gt; 'one', :two =&gt; {:three =&gt; 'three'}}

  c.two.three = 'THREE'
  c.config[:two][:three]    # =&gt; 'THREE'
</pre>
<h3>Attributes</h3>
<p>
Alternative reader and writer methods may be specified as config
attributes. When alternate methods are specified, <a
href="Configurable.html">Configurable</a> assumes the methods are declared
elsewhere and will not define accessors.
</p>
<pre>
  class AlternativeClass
    include Configurable

    config_attr :sym, 'value', :reader =&gt; :get_sym, :writer =&gt; :set_sym

    def get_sym
      @sym
    end

    def set_sym(input)
      @sym = input.to_sym
    end
  end

  alt = AlternativeClass.new
  alt.respond_to?(:sym)     # =&gt; false
  alt.respond_to?(:sym=)    # =&gt; false

  alt.config[:sym] = 'one'
  alt.get_sym               # =&gt; :one

  alt.set_sym('two')
  alt.config[:sym]          # =&gt; :two
</pre>
<p>
Idiosyncratically, true and false may also be provided as reader/writer
values.
</p>
<table>
<tr><td valign="top">true:</td><td>Same as using the defaults, accessors are defined.

</td></tr>
<tr><td valign="top">false:</td><td>Sets the default reader/writer but does not define the accessors (think
&#8216;define reader/writer&#8217; =&gt; false).

</td></tr>
</table>
<p>
Nil is not allowed as a value.
</p>
<h4>Non-reader/writer attributes</h4>
<p>
Attributes provide metadata for how to use configurations in various
contexts. In general, attributes can be used to set any metadata an
application needs. A few attributes are used internally by <a
href="Configurable.html">Configurable</a>.
</p>
<p>
Attribute:: Use::
</p>
<table>
<tr><td valign="top">init:</td><td>When set to false, the config will not initialize itself. Specify when you
manually initialize a config.

</td></tr>
<tr><td valign="top">type:</td><td>Specifies the type of option <a href="ConfigParser.html">ConfigParser</a>
generates for this <a href="Configurable/Config.html">Config</a> (ex:
:switch, :flag, :list, :hidden)

</td></tr>
<tr><td valign="top">desc:</td><td>The description string used in the <a
href="ConfigParser.html">ConfigParser</a> help

</td></tr>
<tr><td valign="top">long:</td><td>The long option (default: key)

</td></tr>
<tr><td valign="top">short:</td><td>The short option.

</td></tr>
</table>
<p>
<a href="Configurable/Validation.html">Validation</a> blocks have default
attributes already assigned to them (ex type). In cases where a
user-defined block gets used multiple times, it may be useful to register
default attributes for that block. To do so, use this pattern:
</p>
<pre>
  class AttributesClass
    include Configurable
    block = c.register(:type =&gt; :upcase) {|v| v.upcase }

    config :a, 'A', &amp;block
    config :b, 'B', &amp;block
  end

  AttributesClass.configurations[:a][:type]   # =&gt; :upcase
  AttributesClass.configurations[:b][:type]   # =&gt; :upcase
</pre>

    </div>


   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000040">initialize_config</a>&nbsp;&nbsp;
      <a href="#M000038">initialize_copy</a>&nbsp;&nbsp;
      <a href="#M000036">new</a>&nbsp;&nbsp;
      <a href="#M000039">open_io</a>&nbsp;&nbsp;
      <a href="#M000037">reconfigure</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">

    <div id="class-list">
      <h3 class="section-bar">Classes and Modules</h3>

      Module <a href="Configurable/ClassMethods.html" class="link">Configurable::ClassMethods</a><br />
Module <a href="Configurable/IndifferentAccess.html" class="link">Configurable::IndifferentAccess</a><br />
Module <a href="Configurable/ModuleMethods.html" class="link">Configurable::ModuleMethods</a><br />
Module <a href="Configurable/Utils.html" class="link">Configurable::Utils</a><br />
Module <a href="Configurable/Validation.html" class="link">Configurable::Validation</a><br />
Class <a href="Configurable/Config.html" class="link">Configurable::Config</a><br />
Class <a href="Configurable/ConfigHash.html" class="link">Configurable::ConfigHash</a><br />
Class <a href="Configurable/NestConfig.html" class="link">Configurable::NestConfig</a><br />
Class <a href="Configurable/OrderedHashPatch.html" class="link">Configurable::OrderedHashPatch</a><br />

    </div>

    <div id="constants-list">
      <h3 class="section-bar">Constants</h3>

      <div class="name-list">
        <table summary="Constants">
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">DEFAULT_ATTRIBUTES</td>
          <td>=</td>
          <td class="context-item-value">Hash.new({})</td>
          <td width="3em">&nbsp;</td>
          <td class="context-item-desc">
A hash of (block, default attributes) for config blocks. The attributes for
nil will be merged with those for the block.

</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">MAJOR</td>
          <td>=</td>
          <td class="context-item-value">0</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">MINOR</td>
          <td>=</td>
          <td class="context-item-value">7</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">TINY</td>
          <td>=</td>
          <td class="context-item-value">0</td>
        </tr>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">VERSION</td>
          <td>=</td>
          <td class="context-item-value">&quot;#{MAJOR}.#{MINOR}.#{TINY}&quot;</td>
        </tr>
        </table>
      </div>
    </div>



    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">config</td>
          <td class="context-item-value">&nbsp;[R]&nbsp;</td>
          <td class="context-item-desc">
A <a href="Configurable/ConfigHash.html">ConfigHash</a> bound to self.
Accessing configurations through config is much slower (although sometimes
more convenient) than through the config accessors.

</td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Class methods</h3>

      <div id="method-M000036" class="method-detail">
        <a name="M000036"></a>

        <div class="method-heading">
          <a href="#M000036" class="method-signature">
          <span class="method-name">new</span><span class="method-args">(*args)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Initializes config, if necessary, and then calls super. If initialize is
overridden without calling super, be sure to call <a
href="Configurable.html#M000040">initialize_config</a> manually within the
<a href="Configurable.html#M000036">new</a> initialize method.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000036-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000036-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable.rb, line 202</span>
202:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
203:     <span class="ruby-identifier">initialize_config</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">instance_variable_defined?</span>(<span class="ruby-identifier">:@config</span>)
204:     <span class="ruby-keyword kw">super</span>
205:   <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000038" class="method-detail">
        <a name="M000038"></a>

        <div class="method-heading">
          <a href="#M000038" class="method-signature">
          <span class="method-name">initialize_copy</span><span class="method-args">(orig)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Reinitializes configurations in the copy such that the <a
href="Configurable.html#M000036">new</a> object has it&#8216;s own set of
configurations, separate from the original object.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000038-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000038-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable.rb, line 218</span>
218:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize_copy</span>(<span class="ruby-identifier">orig</span>)
219:     <span class="ruby-keyword kw">super</span>
220:     <span class="ruby-ivar">@config</span> = <span class="ruby-constant">ConfigHash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">orig</span>.<span class="ruby-identifier">config</span>.<span class="ruby-identifier">store</span>.<span class="ruby-identifier">dup</span>, <span class="ruby-keyword kw">false</span>)
221:   <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000037" class="method-detail">
        <a name="M000037"></a>

        <div class="method-heading">
          <a href="#M000037" class="method-signature">
          <span class="method-name">reconfigure</span><span class="method-args">(overrides={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Reconfigures self with the given overrides. Only the specified configs are
modified.
</p>
<p>
Returns self.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000037-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000037-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable.rb, line 211</span>
211:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">reconfigure</span>(<span class="ruby-identifier">overrides</span>={})
212:     <span class="ruby-identifier">config</span>.<span class="ruby-identifier">merge!</span>(<span class="ruby-identifier">overrides</span>)
213:     <span class="ruby-keyword kw">self</span>
214:   <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Protected Instance methods</h3>

      <div id="method-M000040" class="method-detail">
        <a name="M000040"></a>

        <div class="method-heading">
          <a href="#M000040" class="method-signature">
          <span class="method-name">initialize_config</span><span class="method-args">(overrides={})</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Initializes config. Default config values are overridden as specified.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000040-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000040-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable.rb, line 264</span>
264:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">initialize_config</span>(<span class="ruby-identifier">overrides</span>={})
265:     <span class="ruby-ivar">@config</span> = <span class="ruby-constant">ConfigHash</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">overrides</span>, <span class="ruby-keyword kw">false</span>)
266:     
267:     <span class="ruby-comment cmt"># cache as configs (equivalent to self.class.configurations)</span>
268:     <span class="ruby-comment cmt"># as an optimization</span>
269:     <span class="ruby-identifier">configs</span> = <span class="ruby-ivar">@config</span>.<span class="ruby-identifier">configs</span>
270:     
271:     <span class="ruby-comment cmt"># hash overrides by delegate so they may be set</span>
272:     <span class="ruby-comment cmt"># in the correct order below</span>
273:     <span class="ruby-identifier">initial_values</span> = {}
274:     <span class="ruby-identifier">overrides</span>.<span class="ruby-identifier">each_key</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span><span class="ruby-operator">|</span>
275:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">config</span> = <span class="ruby-identifier">configs</span>[<span class="ruby-identifier">key</span>]
276:         
277:         <span class="ruby-comment cmt"># check that the config may be initialized</span>
278:         <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">config</span>.<span class="ruby-identifier">init?</span>
279:           <span class="ruby-identifier">key</span> = <span class="ruby-identifier">configs</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">configs</span>[<span class="ruby-identifier">k</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">config</span> }
280:           <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;initialization values are not allowed for: #{key.inspect}&quot;</span>
281:         <span class="ruby-keyword kw">end</span>
282:         
283:         <span class="ruby-comment cmt"># check that multiple overrides are not specified for a</span>
284:         <span class="ruby-comment cmt"># single config, as may happen with indifferent access</span>
285:         <span class="ruby-comment cmt"># (ex 'key' and :key)</span>
286:         <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">initial_values</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">config</span>)
287:           <span class="ruby-identifier">key</span> = <span class="ruby-identifier">configs</span>.<span class="ruby-identifier">keys</span>.<span class="ruby-identifier">find</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">k</span><span class="ruby-operator">|</span> <span class="ruby-identifier">configs</span>[<span class="ruby-identifier">k</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">config</span> }
288:           <span class="ruby-identifier">raise</span> <span class="ruby-node">&quot;multiple values map to config: #{key.inspect}&quot;</span>
289:         <span class="ruby-keyword kw">end</span>
290:         
291:         <span class="ruby-comment cmt"># since overrides are used as the ConfigHash store,</span>
292:         <span class="ruby-comment cmt"># the overriding values must be removed, not read</span>
293:         <span class="ruby-identifier">initial_values</span>[<span class="ruby-identifier">config</span>] = <span class="ruby-identifier">overrides</span>.<span class="ruby-identifier">delete</span>(<span class="ruby-identifier">key</span>)
294:       <span class="ruby-keyword kw">end</span>
295:     <span class="ruby-keyword kw">end</span>
296:     
297:     <span class="ruby-comment cmt"># now initialize configs in order</span>
298:     <span class="ruby-identifier">configs</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">config</span><span class="ruby-operator">|</span>
299:       <span class="ruby-keyword kw">next</span> <span class="ruby-keyword kw">unless</span> <span class="ruby-identifier">config</span>.<span class="ruby-identifier">init?</span>
300: 
301:       <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">initial_values</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">config</span>)
302:         <span class="ruby-identifier">config</span>.<span class="ruby-identifier">set</span>(<span class="ruby-keyword kw">self</span>, <span class="ruby-identifier">initial_values</span>[<span class="ruby-identifier">config</span>])
303:       <span class="ruby-keyword kw">else</span>
304:         <span class="ruby-identifier">config</span>.<span class="ruby-identifier">init</span>(<span class="ruby-keyword kw">self</span>)
305:       <span class="ruby-keyword kw">end</span>
306:     <span class="ruby-keyword kw">end</span>
307:   <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000039" class="method-detail">
        <a name="M000039"></a>

        <div class="method-heading">
          <a href="#M000039" class="method-signature">
          <span class="method-name">open_io</span><span class="method-args">(io, mode='r') {|file| ...}</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Opens the file specified by io and yield it to the block. If io is an IO,
it will be yielded immediately, and the mode is ignored. Nil io are simply
ignored.
</p>
<h3>Usage</h3>
<p>
<a href="Configurable.html#M000039">open_io</a> is used to compliment the
io validation, to ensure that if a file is specified, it will be closed.
</p>
<pre>
  class IoSample
    include Configurable
    config :output, $stdout, &amp;c.io    # can be an io or filepath

    def say_hello
      open_io(output, 'w') do |io|
        io &lt;&lt; 'hello!'
      end
    end
  end
</pre>
<p>
In short, this method provides a way to responsibly handle IO and file
configurations.
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000039-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000039-source">
<pre>
     <span class="ruby-comment cmt"># File lib/configurable.rb, line 247</span>
247:   <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">open_io</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">mode</span>=<span class="ruby-value str">'r'</span>)
248:     <span class="ruby-keyword kw">case</span> <span class="ruby-identifier">io</span>
249:     <span class="ruby-keyword kw">when</span> <span class="ruby-constant">String</span>
250:       <span class="ruby-identifier">dir</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">io</span>)
251:       <span class="ruby-constant">FileUtils</span>.<span class="ruby-identifier">mkdir_p</span>(<span class="ruby-identifier">dir</span>) <span class="ruby-keyword kw">unless</span> <span class="ruby-constant">File</span>.<span class="ruby-identifier">directory?</span>(<span class="ruby-identifier">dir</span>)
252:       <span class="ruby-constant">File</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">mode</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">file</span><span class="ruby-operator">|</span> <span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">file</span>) }
253:     <span class="ruby-keyword kw">when</span> <span class="ruby-constant">Integer</span>
254:       <span class="ruby-comment cmt"># note this does not close the io because, as far as I understand, </span>
255:       <span class="ruby-comment cmt"># valid integer file descriptors point to files that are already</span>
256:       <span class="ruby-comment cmt"># open and presumably managed elsewhere</span>
257:       <span class="ruby-keyword kw">yield</span> <span class="ruby-constant">IO</span>.<span class="ruby-identifier">open</span>(<span class="ruby-identifier">io</span>, <span class="ruby-identifier">mode</span>)
258:     <span class="ruby-keyword kw">when</span> <span class="ruby-keyword kw">nil</span> <span class="ruby-keyword kw">then</span> <span class="ruby-keyword kw">nil</span>
259:     <span class="ruby-keyword kw">else</span> <span class="ruby-keyword kw">yield</span>(<span class="ruby-identifier">io</span>)
260:     <span class="ruby-keyword kw">end</span>
261:   <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>