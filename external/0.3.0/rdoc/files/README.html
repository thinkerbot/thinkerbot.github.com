<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Sun Jul 24 20:39:23 -0600 2011</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1><a href="../classes/External.html">External</a></h1>
<p>
Indexing and array-like access to data stored on disk rather than in
memory.
</p>
<h2>Description</h2>
<p>
<a href="../classes/External.html">External</a> provides a way to index and
access array data directly from a file without loading it into memory.
Indexes may be cached in memory or stored on disk with the data file, in
essence giving you arbitrarily large arrays. Externals automatically chunk
and buffer methods like <tt>each</tt> so that the memory footprint remains
low even during enumeration.
</p>
<p>
The main <a href="../classes/External.html">External</a> classes are:
</p>
<ul>
<li><a href="../classes/ExternalIndex.html">ExternalIndex</a> &#8212; for
formatted binary data

</li>
<li><a href="../classes/ExternalArchive.html">ExternalArchive</a> &#8212; for
string data

</li>
<li><a href="../classes/ExternalArray.html">ExternalArray</a> &#8212; for
objects (serialized as YAML)

</li>
</ul>
<p>
The array-like behavior of these classes is developed using modified
versions of the <a href="http://rubyspec.org">RubySpec</a> specification
for Array. The idea is to eventually duck-type all Array methods, including
sort and collect, with acceptable performance.
</p>
<ul>
<li><a href="http://rubyforge.org/projects/external">Rubyforge</a>

</li>
<li><a
href="http://bahuvrihi.lighthouseapp.com/projects/10590-external">Lighthouse</a>

</li>
<li><a href="http://github.com/bahuvrihi/external/tree/master">Github</a>

</li>
</ul>
<h4>Bugs/Known Issues</h4>
<ul>
<li>only a limited set of array methods are currently supported

</li>
<li>currently only [] and []= are fully tested vs RubySpec

</li>
<li>documentation is patchy

</li>
</ul>
<p>
Note also that YAML dump/load of some objects doesn&#8216;t work or
doesn&#8216;t reproduce the object; such objects will not be properly
stored in an <a href="../classes/ExternalArray.html">ExternalArray</a>.
Problematic objects include:
</p>
<p>
Proc and Class:
</p>
<pre>
  block = lambda {}
  YAML.load(YAML.dump(block))         # !&gt; TypeError: allocator undefined for Proc
  YAML.dump(Object)                   # !&gt; TypeError: can't dump anonymous class Class
</pre>
<p>
Carriage returns (&quot;\r&quot;):
</p>
<pre>
  YAML.load(YAML.dump(&quot;\r&quot;))          # =&gt; nil
  YAML.load(YAML.dump(&quot;\r\n&quot;))        # =&gt; &quot;&quot;
  YAML.load(YAML.dump(&quot;string with \r\n inside&quot;))  # =&gt; &quot;string with \n inside&quot;
</pre>
<p>
Chains of newlines (&quot;\n&quot;):
</p>
<pre>
  YAML.load(YAML.dump(&quot;\n&quot;))          # =&gt; &quot;&quot;
  YAML.load(YAML.dump(&quot;\n\n&quot;))        # =&gt; &quot;&quot;
</pre>
<p>
DateTime is loaded as Time:
</p>
<pre>
  YAML.load(YAML.dump(DateTime.now)).class         # =&gt; Time
</pre>
<h2>Usage</h2>
<h3><a href="../classes/ExternalArray.html">ExternalArray</a></h3>
<p>
<a href="../classes/ExternalArray.html">ExternalArray</a> can be
initialized from data using the [] operator and used like an array.
</p>
<pre>
  a = ExternalArray['str', {'key' =&gt; 'value'}]
  a[0]                                # =&gt; 'str'
  a.last                              # =&gt; {'key' =&gt; 'value'}
  a &lt;&lt; [1,2]; a.to_a                  # =&gt; ['str', {'key' =&gt; 'value'}, [1,2]]
</pre>
<p>
<a href="../classes/ExternalArray.html">ExternalArray</a> serializes and
stores entries to an io while building an io_index that tracks the start
and length of each entry. By default <a
href="../classes/ExternalArray.html">ExternalArray</a> will serialize to a
Tempfile and use an Array as the io_index:
</p>
<pre>
  a.io.class                          # =&gt; Tempfile
  a.io.rewind; a.io.read              # =&gt; &quot;--- str\n--- \nkey: value\n--- \n- 1\n- 2\n&quot;
  a.io_index.class                    # =&gt; Array
  a.io_index.to_a                     # =&gt; [[0, 8], [8, 16], [24, 13]]
</pre>
<p>
To save this data more permanently, provide a path to <tt>close</tt>; the
tempfile is moved to the path and a binary index file will be created:
</p>
<pre>
  a.close('example.yml')
  File.read('example.yml')            # =&gt; &quot;--- str\n--- \nkey: value\n--- \n- 1\n- 2\n&quot;

  index = File.read('example.index')
  index.unpack('I*')                  # =&gt; [0, 8, 8, 16, 24, 13]
</pre>
<p>
<a href="../classes/ExternalArray.html">ExternalArray</a> provides
<tt>open</tt> to create ExternalArrays from an existing file; the instance
will use an index file if it exists and automatically reindex the data if
it does not. Manual calls to reindex may be necessary when you initialize
an <a href="../classes/ExternalArray.html">ExternalArray</a> with
<tt>new</tt> instead of <tt>open</tt>:
</p>
<pre>
  # use of an existing index file
  ExternalArray.open('example.yml') do |b|
    File.basename(b.io_index.io.path) # =&gt; 'example.index'
    b.to_a                            # =&gt; ['str', {'key' =&gt; 'value'}, [1,2]]
  end

  # automatic reindexing
  FileUtils.rm('example.index')
  ExternalArray.open('example.yml') do |b|
    b.to_a                            # =&gt; ['str', {'key' =&gt; 'value'}, [1,2]]
  end

  # manual reindexing
  file = File.open('example.yml')
  c = ExternalArray.new(file)

  c.to_a                              # =&gt; []
  c.reindex
  c.to_a                              # =&gt; ['str', {'key' =&gt; 'value'}, [1,2]]
</pre>
<h3><a href="../classes/ExternalArchive.html">ExternalArchive</a></h3>
<p>
<a href="../classes/ExternalArchive.html">ExternalArchive</a> is exactly
like <a href="../classes/ExternalArray.html">ExternalArray</a> except that
it only stores strings (<a
href="../classes/ExternalArray.html">ExternalArray</a> is actually a
subclass of <a href="../classes/ExternalArchive.html">ExternalArchive</a>
which dumps/loads strings).
</p>
<pre>
  arc = ExternalArchive[&quot;swift&quot;, &quot;brown&quot;, &quot;fox&quot;]
  arc[2]                              # =&gt; &quot;fox&quot;
  arc.to_a                            # =&gt; [&quot;swift&quot;, &quot;brown&quot;, &quot;fox&quot;]
  arc.io.rewind; arc.io.read          # =&gt; &quot;swiftbrownfox&quot;
</pre>
<p>
<a href="../classes/ExternalArchive.html">ExternalArchive</a> is useful as
a base for classes to access archival data. Here is a simple parser for <a
href="http://en.wikipedia.org/wiki/Fasta_format">FASTA</a> data:
</p>
<pre>
  # A sample FASTA entry
  # &gt;gi|5524211|gb|AAD44166.1| cytochrome b [Elephas maximus maximus]
  # LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV
  # EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG
  # LLILILLLLLLALLSPDMLGDPDNHMPADPLNTPLHIKPEWYFLFAYAILRSVPNKLGGVLALFLSIVIL
  # GLMPFLHTSKHRSMMLRPLSQALFWTLTMDLLTLTWIGSQPVEYPYTIIGQMASILYFSIILAFLPIAGX
  # IENY

  class FastaEntry
    attr_reader :header, :body

    def initialize(str)
      @body = str.split(/\r?\n/)
      @header = body.shift
    end
  end

  class FastaArchive &lt; ExternalArchive
    def str_to_entry(str); FastaEntry.new(str); end
    def entry_to_str(entry); ([entry.header] + entry.body).join(&quot;\n&quot;); end

    def reindex
      reindex_by_sep('&gt;', :entry_follows_sep =&gt; true)
    end
  end

  require 'open-uri'
  fasta = FastaArchive.new open('http://external.rubyforge.org/doc/tiny_fasta.txt')
  fasta.reindex

  fasta.length                        # =&gt; 5
  fasta[0].body                       # =&gt; [&quot;MEVNILAFIATTLFVLVPTAFLLIIYVKTVSQSD&quot;]
</pre>
<p>
The non-redundant <a href="ftp://ftp.ncbi.nih.gov/blast/db/FASTA/">NCBI
protein database</a> contains greater than 7 million FASTA entries in a
3.56 GB file; <a href="../classes/ExternalArchive.html">ExternalArchive</a>
is targeted at files that size, where lazy loading of data and a small
memory footprint are critical.
</p>
<h3><a href="../classes/ExternalIndex.html">ExternalIndex</a></h3>
<p>
<a href="../classes/ExternalIndex.html">ExternalIndex</a> provides
array-like access to formatted binary data. The index of an uncached <a
href="../classes/ExternalArray.html">ExternalArray</a> is an <a
href="../classes/ExternalIndex.html">ExternalIndex</a> configured for
binary data like &#8216;II&#8217;; two integers corresponding to the start
position and length an entry.
</p>
<pre>
  index = ExternalIndex[1, 2, 3, 4, 5, 6, {:format =&gt; 'II'}]
  index.format                        # =&gt; 'I*'
  index.frame                         # =&gt; 2
  index[1]                            # =&gt; [3,4]
  index.to_a                          # =&gt; [[1,2], [3,4], [5,6]]
</pre>
<p>
<a href="../classes/ExternalIndex.html">ExternalIndex</a> handles arbitrary
packing formats, opening many possibilities:
</p>
<pre>
  Tempfile.new('sample.txt') do |file|
    file &lt;&lt; [1,2,3].pack(&quot;IQS&quot;)
    file &lt;&lt; [4,5,6].pack(&quot;IQS&quot;)
    file &lt;&lt; [7,8,9].pack(&quot;IQS&quot;)
    file.flush

    index = ExternalIndex.new(file, :format =&gt; &quot;IQS&quot;)
    index[1]                          # =&gt; [4,5,6]
    index.to_a                        # =&gt; [[1,2,3], [4,5,6], [7,8,9]]
  end
</pre>
<h2>Installation</h2>
<p>
<a href="../classes/External.html">External</a> is available from <a
href="http://rubyforge.org/projects/external">RubyForge</a>. Use:
</p>
<pre>
  % gem install external
</pre>
<h2>Info</h2>
<p>
Copyright (c) 2006-2008, Regents of the University of Colorado.
</p>
<table>
<tr><td valign="top">Developer:</td><td><a href="http://bahuvrihi.wordpress.com">Simon Chiang</a>, <a
href="http://biomol.uchsc.edu/">Biomolecular Structure Program</a>, <a
href="http://hsc-proteomics.uchsc.edu/hansenlab/">Hansen Lab</a>

</td></tr>
<tr><td valign="top">Support:</td><td>CU Denver School of Medicine Deans Academic Enrichment Fund

</td></tr>
<tr><td valign="top">Licence:</td><td><a href="MIT-LICENSE.html">MIT-Style</a>

</td></tr>
</table>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>