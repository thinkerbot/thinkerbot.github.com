PROJECTS = %w{
  thinkerbot/configurable
  thinkerbot/shell_test
}
ROOT_DIR = File.expand_path('../..', __FILE__)
GEMS_DIR = File.expand_path('../gems', __FILE__)
PROJECT_DIR = File.expand_path('../projects', __FILE__)

def capture_sh(str)
  puts str
  `#{str}`
end

def each_project
  PROJECTS.each do |project_path|
    project_name = File.basename(project_path)
    project_dir = File.join(PROJECT_DIR, project_name)
    yield(project_path, project_name, project_dir)
  end
end

def in_each_project_dir
  each_project do |project_path, project_name, project_dir|
    Dir.chdir(project_dir) do
      yield(project_name)
    end if File.exists?(project_dir)
  end
end

def each_gemspec
  Dir.glob File.join(GEMS_DIR, '*.gem') do |gemfile|
    gemspec = capture_sh("gem specification '#{gemfile}' --ruby --backtrace")
    yield gemfile, eval(gemspec)
  end
end
#
# Dependency tasks
#

desc 'Bundle dependencies'
task :bundle do
  output = `bundle check 2>&1`
  
  unless $?.to_i == 0
    puts output
    sh "bundle install 2>&1"
    puts
  end
end

#
# Site tasks
#

desc 'Build site'
task :build => [:bundle, :rdoc] do
  Dir.chdir(ROOT_DIR) do
    capture_sh "jekyll --pygments --safe"
  end
end

task :rdoc do
  latest = {}
  each_gemspec do |gemfile, spec|
    code_dir = File.join(GEMS_DIR, spec.full_name)
    unless File.exists?(code_dir)
      capture_sh %Q{gem unpack '#{gemfile}' --target '#{GEMS_DIR}' --backtrace}
    end

    rdoc_dir = File.join(ROOT_DIR, spec.name, spec.version.to_s, 'rdoc')
    unless File.exists?(rdoc_dir)
      Dir.chdir(code_dir) do
        files =  spec.files.select {|file| File.extname(file) == '.rb' }
        files += spec.extra_rdoc_files
        FileUtils.mkdir_p File.dirname(rdoc_dir)
        capture_sh "rdoc -o '#{rdoc_dir}' '#{spec.rdoc_options.join("' '")}' '#{files.join("' '")}'"
      end
    end

    current = latest[spec.name]
    if current.nil? || current < spec.version
      latest[spec.name] = spec.version
    end
  end

  latest.each_pair do |name, version|
    latest_rdoc_dir = File.join(ROOT_DIR, name, version.to_s, 'rdoc')
    rdoc_dir = File.join(ROOT_DIR, name, 'rdoc')
    FileUtils.rm_r(rdoc_dir) if File.exists?(rdoc_dir)
    FileUtils.cp_r(latest_rdoc_dir, rdoc_dir)
  end
end

#
# Project tasks
#

desc 'fetch gems for each project'
task :fetch do
  FileUtils.mkdir_p GEMS_DIR

  Dir.chdir(GEMS_DIR) do
    each_project do |project_path, project_name, project_dir|
      list = capture_sh "gem list -a --remote #{project_name}"

      list =~ /^#{project_name} \((.*)\)$/
      $1.to_s.split(', ').each do |version|
        unless File.exists?("#{project_name}-#{version}.gem")
          capture_sh "gem fetch #{project_name} -v #{version}"
        end
      end
    end
  end
end

desc 'clone each project'
task :clone do
  Dir.chdir(ROOT_DIR) do
    each_project do |project_path, project_name, project_dir|
      unless File.exists?(project_dir)
        capture_sh "git submodule add git@github.com:#{project_path}.git #{project_dir}"
      end
    end
  end
end

desc 'checkout gh-pages for each project'
task :checkout => :clone do
  in_each_project_dir do
    capture_sh "git checkout gh-pages"
    unless $?.exitstatus == 0
      capture_sh "git symbolic-ref HEAD refs/heads/gh-pages"
      capture_sh "rm .git/index"
      capture_sh "git clean -fdx"
      capture_sh 'echo "My GitHub Page" > index.html'
      capture_sh "git add ."
      capture_sh "git commit -a -m 'First pages commit'"
    end
  end
end

desc 'commit changes'
task :commit do
  each_project do |project_path, project_name, project_dir|
    site_dir = File.join(ROOT_DIR, '_site', project_name)
    FileUtils.mv File.join(project_dir, '.git'), File.join(site_dir, '.git')
    FileUtils.rm_r project_dir
    FileUtils.mv site_dir, project_dir
  end
  in_each_project_dir do |project_name|
    capture_sh "git add ."
    capture_sh "git add -u"
    capture_sh "git commit -m 'updated to thinkerbot.github.com@#{`git log -n1 --format=%H`}'"
  end
end

desc 'push changes'
task :push do
  in_each_project_dir do
    capture_sh "git push --all"
  end
end
